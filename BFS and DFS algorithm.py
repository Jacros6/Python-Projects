# -*- coding: utf-8 -*-
"""proj3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Z049e1Jo3f9Fj6EaOXpc2iGGJWY1y3mz
"""

!pip install extended-int
!pip install Pillow
from typing import NamedTuple
import PIL
from PIL import Image
import urllib.request
from numbers import Integral, Real
from queue import PriorityQueue
from queue import Queue
import heapq
import io, sys


#Program has difficulty with starting at border vertex and ending with border vertexes. When I was testing it had difficulties with border outputs such as 0,0 but everything else works as intended
#
#
#
#
#
#
class Point:
  def __init__(self, x, y):
    self.x = x
    self.y = y


#s = [1, 1]
#t = [14,14]

#img = Image.open("maze.bmp")


def main():
  print("input maze bmp file for problem")
  i = input()
  img = Image.open(i)
  print("input starting pixel x")
  sx = input()
  print("input starting pixel y")
  sy = input()
  s = [int(sx), int(sy)]
  print("input goal pixel x")
  tx = input()
  print("input goal pixel y")
  ty = input()
  t = [int(tx), int(ty)]
  print("input name of BreadthFirstSearch output bmp")
  j = input()
  im1 = BreadthFirstSearch(img, s, t)
  im1 = im1.save(j)
  img = Image.open("maze.bmp")
  print("input name of BestFirstSearch output bmp")
  k = input()
  im2 = BestFirstSearch(img, s, t)
  im2 = im2.save(k)
  img

def BestFirstSearch(img, s, t):
  pq = []

  visited = []
  for i in range(img.width):
    col = []
    for j in range(img.height):
      col.append(False)  
    visited.append(col)

  visited[s[0]][s[1]] = True
  d = []
  prev = []
  h = []
  infinity = [int_inf, int_inf]
  zero = [0,0]
  for i in range(img.height):
    col = []
    col2 = []
    col3 = []
    for j in range(img.width):
      col.append(infinity)
      col2.append(zero)
    d.append(col)
    prev.append(col2)

  for i in range(img.height):
    col = []
    for j in range(img.width):
      col.append(abs(j - t[0]) + abs(i - t[1]))
    h.append(col)

  d[s[0]][s[1]] = [0,0]
  u = [s[0], s[1]]
  print(u)
  v = [0,0]
  Red = 255,0,0
  Green = 0, 255, 0
  s2 = s[0],s[1]
  img.putpixel(s2, Green)    
  heapq.heappush(pq, (h[s[0]][s[1]], s))
  counterG = 1
  print(pq)
  while(len(pq) != 0 and visited[t[0]][t[1]] == False):
    u = pq[0][1]
    s1 = pq[0][0]
    heapq.heappop(pq)
    v = [u[0] + 1, u[1]]
    v2 = v[0],v[1]
    img.show()
    color = img.getpixel(v2)
    if v[0] < img.width and visited[v[0]][v[1]] == False and color[0] > 100 and color[1] > 100 and color[2] > 100:
      visited[v[0]][v[1]] = True
      img.putpixel(v2, Green)  
      d[v[0]][v[1]] = d[u[0] + 1][u[1]]
      prev[v[0]][v[1]] = [u[0],u[1]]
      counterG = counterG + 1
      heapq.heappush(pq, (h[v[0]][v[1]], v))
    
    v = [u[0] - 1, u[1]]
    v2 = v[0],v[1]
    if v[0]> -1:
      color = img.getpixel(v2)
      if v[0]> -1 and visited[v[0]][v[1]] == False and color[0] > 100 and color[1] > 100 and color[2] > 100:
        visited[v[0]][v[1]] = True
        img.putpixel(v2, Green)      
        d[v[0]][v[1]] = d[u[0] - 1][u[1]]
        prev[v[0]][v[1]] = [u[0],u[1]]      
        counterG = counterG + 1
        heapq.heappush(pq, (h[v[0]][v[1]], v))
        

    v = [u[0], u[1] + 1]
    v2 = v[0],v[1]
    if v[1]<img.height:
      color = img.getpixel(v2)
      if v[1]<img.height and visited[v[0]][v[1]] == False and color[0] > 100 and color[1] > 100 and color[2] > 100:    
        visited[v[0]][v[1]] = True
        img.putpixel(v2, Green)
        d[v[0]][v[1]] = d[u[0]][u[1] + 1]
        prev[v[0]][v[1]] = [u[0],u[1]]      
        counterG = counterG + 1        
        heapq.heappush(pq, (h[v[0]][v[1]], v))

    v = [u[0], u[1] - 1]
    v2 = v[0],v[1] 
    if v[1]> -1:
      color = img.getpixel(v2)
      if v[1]> -1 and visited[v[0]][v[1]] == False and color[0] > 100 and color[1] > 100 and color[2] > 100:
        visited[v[0]][v[1]] = True
        img.putpixel(v2, Green)
        d[v[0]][v[1]] = d[u[0]][u[1] - 1]
        prev[v[0]][v[1]] = [u[0],u[1]]      
        counterG = counterG + 1
        heapq.heappush(pq, (h[v[0]][v[1]], v))
  print("number of green steps", counterG)
  counter = 0
  v = [t[0], t[1]]
  while v[0] != s[0] or v[1] != s[1]:
     counter = counter + 1
     v2 = v[0],v[1]
     img.putpixel(v2, Red)
     v = prev[v[0]][v[1]] 
  counter = counter + 1
  print("number of red steps", counter)
  t2 = s[0],s[1]
  img.putpixel(t2, Red)
  img.show()
  return img


#start of BreadthFirstSearch
def BreadthFirstSearch(img, s, t):
  q = Queue()
  q.put(s)

  visited = []
  for i in range(img.width):
    col = []
    for j in range(img.height):
      col.append(False)  
    visited.append(col)

  visited[s[0]][s[1]] = True
  d = []
  prev = []
  infinity = [int_inf, int_inf]
  zero = [0,0]
  for i in range(img.height):
    col = []
    col2 = []
    for j in range(img.width):
      col.append(infinity)
      col2.append(zero)
    d.append(col)
    prev.append(col2)


  d[s[0]][s[1]] = [0,0]
  u = [s[0], s[1]]
  print(u)
  v = [0,0]
  Red = 255,0,0
  Green = 0, 255, 0
  s2 = s[0],s[1]
  img.putpixel(s2, Green)
  counterG = 1
  #print(img.getpixel(u2))
  while(q.empty() == False and visited[t[0]][t[1]] == False):
    u = q.get()
    v = [u[0] + 1, u[1]]
    v2 = v[0],v[1]
    img.show()
    color = img.getpixel(v2)
    if v[0] < img.width and visited[v[0]][v[1]] == False and color[0] > 100 and color[1] > 100 and color[2] > 100:
      visited[v[0]][v[1]] = True
      img.putpixel(v2, Green)  
      d[v[0]][v[1]] = d[u[0] + 1][u[1]]
      prev[v[0]][v[1]] = [u[0],u[1]]
      counterG = counterG + 1
      q.put(v)
    
    v = [u[0] - 1, u[1]]
    v2 = v[0],v[1]
    if v[0]> -1:
      color = img.getpixel(v2)
      if v[0]> -1 and visited[v[0]][v[1]] == False and color[0] > 100 and color[1] > 100 and color[2] > 100:
        visited[v[0]][v[1]] = True
        img.putpixel(v2, Green)      
        d[v[0]][v[1]] = d[u[0] - 1][u[1]]
        prev[v[0]][v[1]] = [u[0],u[1]]      
        counterG = counterG + 1
        q.put(v)

    v = [u[0], u[1] + 1]
    v2 = v[0],v[1]
    if v[1]<img.height:
      color = img.getpixel(v2)
      if v[1]<img.height and visited[v[0]][v[1]] == False and color[0] > 100 and color[1] > 100 and color[2] > 100:    
        visited[v[0]][v[1]] = True
        img.putpixel(v2, Green)
        d[v[0]][v[1]] = d[u[0]][u[1] + 1]
        prev[v[0]][v[1]] = [u[0],u[1]]     
        counterG = counterG + 1 
        q.put(v)

    v = [u[0], u[1] - 1]
    v2 = v[0],v[1] 
    if v[1]> -1:
      color = img.getpixel(v2)
      if v[1]> -1 and visited[v[0]][v[1]] == False and color[0] > 100 and color[1] > 100 and color[2] > 100:
        visited[v[0]][v[1]] = True
        img.putpixel(v2, Green)
        d[v[0]][v[1]] = d[u[0]][u[1] - 1]
        prev[v[0]][v[1]] = [u[0],u[1]] 
        counterG = counterG + 1             
        q.put(v)

  print("number of green steps:", counterG)
  counter = 0      
  v = [t[0], t[1]]
  while v[0] != s[0] or v[1] != s[1]:
     counter = counter + 1
     v2 = v[0],v[1]
     img.putpixel(v2, Red)
     v = prev[v[0]][v[1]]
  counter = counter + 1
  print("number of red steps:", counter)
  t2 = s[0],s[1]
  img.putpixel(t2, Red)
  img.show()
  return img

main()
#BestFirstSearch(img, s, t)
#BreadthFirstSearch(img, s, t)